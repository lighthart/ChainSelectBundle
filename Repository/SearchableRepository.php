<?php

namespace Mesd\OrmedBundle\Repository;


/**
 * BillerRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */

    // I have no idea why these are here

class SearchableRepository extends JSONRepository
{
    private $rootAlias = 'root';

    private $defaultSearches = [
        'numbers' => [],
        'strings' => [],
        'dates'   => [],
    ];

    public function getSearch(array $options = [])
    {
        $root = $this->rootAlias;
        $qb   = $this->createQueryBuilder($this->rootAlias);

        // this forces the result array keys to be biller ids
        $qb->add('from',
            new \Doctrine\ORM\Query\Expr\From(
                $qb->getDqlPart('from')[0]->getFrom(),
                $root,
                $root . ".id"
            ), false
        );

        $options = array_merge(
            [
                // filter is the search criteria
                'filter'   => null,

                // searches is an array of fields to search different than default
                'searches' => null,

                'limit'  => null,
                'page'   => null,
                'order'  => null,
                'count'  => null,
                'id'     => null,
                'qbOnly' => null,
            ],
            $options
        );

        if ($options['limit']) {
            $qb->setMaxResults($options['limit']);
        }

        if (!$options['count']) {
            if ($options['page']) {
                // Limit hardcoded to 10 results if not specified
                // Limit should not automatically be set to 10 in all cases
                // In case this query is used outside the context of paging.
                $qb->setFirstResult(($options['page']-1) * ($options['limit'] ?: 10));
            }

            if (!$options['order']) {
                $options['order'] = $this->defaultOrder;
            }
            // order string should be 'column ASC'
            array_map(
                function ($o, $d) use ($qb, $root) {
                    $qb->addOrderBy($o, $d);
                }, array_keys($options['order']), $options['order']);
        }

        if ('array' != gettype($options['id'])) {
            if (false !== strpos($options['id'], ',')) {
                $options['id'] = explode(',', $options['id']);
            }
        }

        if ($options['id']) {
            if (gettype($options['id']) == 'array') {
                $qb->andWhere($qb->expr()->in($root . '.id', ':id'));
                $qb->setParameter('id', $options['id']);
            } else {
                $qb->andWhere($qb->expr()->eq($root . '.id', ':id'));
                $qb->setParameter('id', $options['id']);
            }
        }

        if ($options['filter']) {
            // the below need to be configured based on entity code
            // and calls JSON repository superclass->addFilter
            if (!$options['searches']) {
                $options['searches'] = $this->defaultSearches;
            }
            $qb = $this->addFilter($qb, $options['filter'], $this->defaultSearches);
        }

        if (isset($options['count']) && $options['count']) {
            $qb->select($qb->expr()->count('DISTINCT ' . $root));

            return $qb->getQuery()->getSingleScalarResult();
        } elseif (isset($options['qbOnly']) && $options['qbOnly']) {
            return $qb;
        } else {
            return $qb->getQuery()->getResult();
        }
    }
}
